################################################################################
# Copyright (c) 2008 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus.store.mapped package (Spanish)
################################################################################

#
# Schema mapping, columns etc
#
020003=Las columnas "{0} " han sido definido con {1} columnas, pero hay solamente {2} en otro lado!
020004=Las columnas "{0}" tiene una columna "{1}" que ha sideo definido associar con "{2}" pero este no existe!
020005=Las columnas "{0}" numero de columna {1} no tiene otras columnas para asociar!
020006=Las columnas "{0}" tiene una columna "{1}" que ha sido asociado dos veces!
020007=El nombre de la columna "{0}", de la tabla "{1}" esta duplicado. No se pueden mapear varios campos a una misma columna. El columnas utilizada {2} y {3}.
020008=? datastore-identity|index columns|other non mapped to any field ?

020015=Ha excedido el maximum de {0} claves foráneas por la tabla {1}
020016=Ha excedido el maximo de {0} índices por la tabla {1}


020185=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
020186=El campo "{0}" esta declarado para usar algunas claves ajenas y tiene una especificacion de las columnas, pero el numero de columnas ({1}) no es igual que el numero de claves ajenas de este campo ({2}).
020187=Una columna añadido por el tipo "{0}" del campo "{1}" (declarada para usar "subclass-table")
020188=Una columna añadido por la implementación "{0}" del campo "{1}" (declarada como referencia - "interface" o java.lang.Object)
020189=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) ("{1}") y debe tener una implementación "{2}", pero esta clase no existe!
020190=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) y debe tener una implementación "{1}" pero este es Interface también!

#
# Identifiers
#
039000=Caja de identificación "{0}" no esta apoyada. Por favor elige otra
039001=Factoria de identificaciones las queria en "{0}" pero el adaptador del base de datos no lo apoya. Ya usamos "{1}"
039002=Factoria de identificaciones las quiere en "{0}" pero es imposible con este adaptador de base de datos, y no hay otra opción.


055009=El objeto "{0}" tiene campo "{1}" con una relacion bidireccional, y añadiendo el elemento "{2}" aqi que ponemos el valor del dueño en el elemento.
055010=El objeto "{0}" tiene una relacion 1-N bidireccional "{1}" y vamos a quitar un elemento. Elemento "{2}" va a tener el dueño anulado.

#
# SCO
#
056000=¡El campo "{0}" es una matriz, pero no hay MetaData de <array>!
056001=¡El campo "{0}" es una collección, pero no hay MetaData de <collection>!
056002=¡El campo "{0}" es una mapa, pero no hay MetaData de <map>!
056003=¡El MetaData de la clase de elemento "{0}" del campo de collección "{1}" no esta!
056004=¡El MetaData de la clase de elemento "{0}" del campo de mapa "{1}" no esta!
056005=El estatement del iterador es nulo !!
056006=Solicitud de iterar ha fallado : {0}
056007=Solicitud de tamaño ha fallado : {0}
056008=Solicitud de contener ha fallado : {0}
056009=Solicitud de añadir ha fallado : {0}
056010=Solicitud de cambiar la clave embedded ha fallado : {0}
056011=Solicitud de cambiar el valor embedded ha fallado : {0}
056012=Solicitud de borrar ha fallado : {0}
056013=Solicitud de vaciar ha fallado : {0}
056014=Solicitud de obtener ha fallado : {0}
056015=Solicitud de poner ha fallado : {0}
056016=Solicitud de poner ha fallado : {0}
056017=Solicitud de IndexOf ha fallado : {0}
056018=Solicitud de ContainsKey ha fallado : {0}
056019=Solicitud de ContainsValue ha fallado : {0}
056020=Solicitud de MaxAdapterColumnId ha fallado : {0}
056021=No se puede preguntar sobre una Collection de elementos de segunda clase
056022=No se puede preguntar sobre un Map de valores de segunda clase
056023=GetIndices ha fallado : unos elementos no existen : {0}

056024=El campo "{0}" tiene "mapped-by" como "{1}" pero ese campo "mapped-by" no existe en la clase "{2}".
056025=El campo "{0}" tiene "mapped-by" como "{1}" pero el tipo de ese es incorrecto ({2}). El campo de "mapped-by" tiene que ser del tipo "{3}"
056026=El campo dueño {0} de la clase de elemento {1} tiene un tipo incorrecto "{2}". Debe ser "{3}"
056027=Could not update the foreign key using statement : {0}

#
# SCO Collection
#
056028=El campo de collección "{0}" debe contener el elemento "{1}" pero este elemento esta almacenado como "embedded" en otro campo. ¡Es imposible!. No se puede almacenar un objeto como SCO ("embedded") y como FCO al mismo tiempo

056029=La clase "{0}" tiene campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
056030=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"

056031=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. DataNucleus no apoya esta situación.
056032=La collección tiene element-type "{0}" que es interface y tiene más que una implementación. DataNucleus no apoya el uso de los interfaces cuando haya más que una implementación disponible.

056033=La clase {0} no es de un tipo valido para esta collección (Campo "{1}"). Debe ser "{2}" o algun subclase

056034=La borracion del elemento de FK Collection borra los elementos porque el campo es "dependent"
056035=La borracion del elemento de FK Collection ha borrado los elementos porque las columnas de owner/index no son nulable
056036=La borracion del elemento de FK Collection ha anulado el FK y los ha dejado en la base de datos.

056037=El objeto "{0}" tiene una colleccion "{1}" pero el elemento "{2}" no tiene el dueño puesto. Manejando la relación y poniendo el dueño.
056038=El objeto "{0}" tiene una colleccion "{1}" pero el elemento "{2}" tiene el dueño de "{3}". ¡Usted tiene que corregirlo!

#
# SCO Set
#
056039=Elementos nulos no estan permitidos en persistent sets.
056040=El campo de collección "{0}" tenia que añadir el elemento "{1}" a la relación M-N pero este elemento ya existe.

#
# SCO List
#
056041=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}". ¿Quizas usted haya declarado el campo como java.util.Collection pero lo haya instanciado como java.util.List sin poner <order> en el MetaData?
056042=La borracion del elemento de Inverse List ha borrado el elemento porque las columnas de owner/index no son nulable
056043=La borracion del elemento de Inverse List ha quitado el elemento de List y lo ha dejado en la base de datos.
056044=El campo "{0}" ha sido instanciado como una lista usando tabla de juntar pero la tabla no tiene una columna de "order". Por favor, ponga un elemento <order> en el MetaData.

#
# SCO Array
#
056045=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. DataNucleus no apoya esta situación.
056046=La clase "{0}" tiene campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
056047=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"
056048=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}"
056049=La matriz tiene element "{0}" que es interface y tiene más que una implementación. DataNucleus no apoya el uso de los interfaces cuando haya más que una implementación disponible.

#
# SCO Map
#
056050=La Mapa "{0}" no tiene ninguna especificacion <key mapped-by=...>. Usted tiene que poner un <key mapped-by=...> porque se almacena la llave en un campo en el valor.
056051=¡La Mapa "{0}" tiene un tipo de llave de "{1}" pero el campo de la llave en el valor es de tipo "{2}"!
056052=¡La clase de valor "{0}" tiene que contener un campo "{1}" que representa la llave, pero no hay ningun campo con este nombre!

056057=La Mapa "{0}" no tiene ninguna especificacion <value mapped-by=...>. Usted tiene que poner un <value mapped-by=...> porque se almacena el valor en un campo en la llave.
056058=¡La Mapa "{0}" tiene un tipo de valor de "{1}" pero el campo de; valor en la llave es de tipo "{2}"!
056059=¡La clase del llave "{0}" tiene que contener un campo "{1}" que representa el valor, pero no hay ningun campo con este nombre!

056053=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de los valores "{2}" campo de llave "{3}"
056054=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de las llaves "{2}" campo de valor "{3}"
056055=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
056056=¡La clase "{0}" tiene un campo de Mapa "{1}" pero no hay ningun Mapping en la tabla de la clase de valores "{2}" para llegar al dueño!

056060=No se puede escribir la llave de otro Persistence Manager
056061=No se puede escribir valor de otro Persistence Manager
056062=Llaves nulas no estan permitidas en persistent maps.
056063=Valores nulos no estan permitidos en persistent maps.
056064=La clase {0} no es de un tipo valido para una llave de este Map. Debe ser {1}
056065=La clase {0} no es de un tipo valido para un valor de este Map. Debe ser {1}
056066=El Mapa tiene value-type "{0}" que es interface. DataNucleus no apoya totalmente un value-type asi. Por favor cambialo por una clase.
056067=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero este campo de "mapped-by" no existe en la clase "{2}".
056068=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero el tipo esta incorrecta ({2}). El campo de "mapped-by" debe ser de tipo "{3}"

056069=¡El MetaData de la clase de la llave "{0}" del campo de la mapa "{1}" no esta!
056070=¡El MetaData de la clase del valor "{0}" del campo de la mapa "{1}" no esta!

056071=El campo "{0}" es una mapa de ForeignKey. No hay ningun key/value "mapped-by". Usted tiene que poner <key mapped-by="..."> para usar una relación de mapa de ForeignKey.
056072=El campo "{0}" es una mapa de ForeignKey donde se almacena la llave en el valor, pero el valor no es PersistenceCapable (es "{1}"). Usted tiene que usar un valor de PersistenceCapable para usar este tipo de relación
056072=El campo "{0}" es una mapa de ForeignKey donde se almacena el valor en la llave, pero la llave no es PersistenceCapable (es "{1}"). Usted tiene que usar una llave de PersistenceCapable para usar este tipo de relación
056074=El campo "{0}" es una mapa de ForeignKey donde el valor se almacena en la llave, pero DataNucleus no apoya esta relación




057023=La clase "{0}" no tiene su propia tabla y no hay subclases con tablas tampoco. No es posible crear el esquema!
