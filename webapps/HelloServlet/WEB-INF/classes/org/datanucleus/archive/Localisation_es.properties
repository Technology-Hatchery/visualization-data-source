################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contributors:
#     ...
#
# Resources for org.datanucleus package (Spanish)
################################################################################
#
# ClassLoader
#
001000=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH.
001001=PersistenceManagerFactory tiene ClassLoaderResolver de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
001002=ClassLoaderResolver plugin con clase "{0}" pero no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
001003=ClassLoaderResolver para la clase "{0}" ha dado error en la creación : {1}
001004=¡La clase {0} no esta en el CLASSPATH! [ClassResolver llamado por {1} (linea {2})]
001005=¡La clase {0} no esta en el CLASSPATH!.
001006=¡La clase "{0}" no esta en el CLASSPATH!. Usted tiene que tener "{1}" en el CLASSPATH!

#
# DatastoreIdentity
#
002001=PersistenceManagerFactory tiene datastore-identity de nombre "{0}" pero el mecanismo de plugin de DataNucleus no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
002002=datastore-identity "{0}" usa clase "{1}" pero la clase no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
#
# L1 Cache
#
003001=Cache de nivel 1 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
003002=Cache de nivel 1 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
003003=Cache de nivel 1 del tipo "{0}" inicializada
003004=Objeto "{0}" (id="{1}") añadido a la Cache de nivel 1 (loadedFlags="{2}")
003005=Objeto "{0}" (id="{1}") cambiado en la Cache de nivel 1 (loadedFlags="{2}")
003006=Intenta añadir a la Cache de nivel 1 un objeto con id nulo. Rechazado.
003007=Objeto con id "{0}" no esta en la Cache de nivel 1 [tamaño = {1}]
003008=Objeto "{0}" (id="{1}") usado de la Cache nivel 1 (loadedFlags="{2}") [tamaño = {3}]
003009=Objeto "{0}" (id="{1}") borrado de la Cache de nivel 1 [tamaño = {2}]
003010=Object "{0}" (id="{1}") no podia ser borrado de la Cache de nivel 1 - no existia
003011=Cache de nivel 1 vaciada.
003012=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 1
#
# L2 Cache
#
004000=Cache de nivel 2 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
004001=Cache de nivel 2 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
004002=Cache de nivel 2 del tipo "{0}" inicializada
004003=Objeto "{0}" (id="{1}") añadido a la Cache de nivel 2 (loadedFlags="{2}", relationFields="{3}")
004004=Intenta añadir a la Cache de nivel 2 un objeto con id nulo. Rechazado.
004005=Objeto con id "{0}" no esta en la Cache de nivel 2 [tamaño = {1}]
004006=Objeto "{0}" (id="{1}") usado de la Cache nivel 2 (loadedFlags="{2}", relationFields="{3}") [tamaño = {4}]
004007=Objeto "{0}" (id="{1}") borrado de la Cache de nivel 2 [tamaño = {2}]
004008=Objeto "{0}" (id="{1}") no podia ser borrado de la Cache de nivel 2 - no existia
004009=Cache de nivel 2 vaciada.
004010=Objeto "{0}" (id="{1}") va a ser cambiado para ser referenciado por id="{2}" en la Cache de nivel 2
004011=Intenta almacenar un valor nulo en la Cache. No es posible.
004012=No se puede añadir el objeto "{0}" a la Cache de nivel 2 porque esta conectado a un PersistenceManager.
004013=Objeto "{0}" (id="{1}") cambiado en la Cache de nivel 2 (loadedFlags="{2}")
004014=Objeto con identidad="{0}") borrado de la Cache de nivel 2 porque ha cambiado pero ha sido GCed [tamaño = {1}]
#
# FetchPlan
#
006000=El campo "{0}" del fetch-group "{1}" no existe en la clase "{2}
006001=Fetch-group "{0}" jerarquizado en el fetch-group "{1}" no existe en la clase "{2}"
006002=El valor {0} no tiene ningun sentido para maxFetchDepth. Usted tiene que poner -1 (no hay limite) o un valor positivo.
006003=No se puede cambiar los raices de detachar antes de commit().
006004=Intenta añadir el campo "{0}" al fetch group de la clase "{1}", pero el campo no existe en la clase!
#
# Reachability
#
007000=Object "{0}" (id="{1}") estado de vida "{2}" añadido a la lista de alcanzables al commit.
007001=Haciendo la calculación de alcanzables con el campo "{0}" que es nulo
007002=Haciendo la calculación de alcanzables con el contenedor de SCO al campo "{0}"
007003=Haciendo la calculación de alcanzables en el campo de array "{0}"
007004=Haciendo la calculación de alcanzables en el campo de PC "{0}"
007005=No podremos encontrar el StateManager del objeto de PC "{0}" al campo "{1}" - ignorandolo
007006=El campo "{0}" ha sido seleccionado no usar "persistence-by-reachability" por persistir. No vamos a persistir este campo.
007007=El campo "{0}" va a ser persistido por "persistence-by-reachability".
007008=El campo "{0}" ha sido seleccionado no usar "persistence-by-reachability" por cambio. No vamos a persistir este campo.
007009=El campo "{0}" va a ser cambiado por "persistence-by-reachability".

#
# ObjectManagerFactory
#
008000=DataNucleus Persistence Factory - Vendor: "{0}"  Versión: "{1}"
008001=DataNucleus Persistence Factory inicializado para la base de datos URL="{0}" driver="{1}" userName="{2}"
008002=No podemos utilizar DataNucleus Persistence Factory como ya esta cerrado.
008003=No hay ningun adaptador de API "{0}". Usando lo que tenemos ahora mismo
008004=No hay ningun StoreManager del tipo "{0}". Por favor compruebe que usted ha puesto "datanucleus.storeManagerType" correctamente y que todos los plugins necesarios estan en el CLASSPATH
008005=No hay ningun StoreManager para la clave de URL de base de datos "{0}". Por favor compruebe que los plugins existen en el CLASSPATH (datanucleus-rdbms?, datanucleus-db4o?), y piensa de poner la propiedad de persistencia "datanucleus.storeManagerType" al tipo de base de datos que quiere e.g rdbms, db4o
008006=El "implementation creator" de DataNucleus "{0}" no existe en el CLASSPATH. Para utilizar JDO "PersistenceManager.newInstance()" usted tiene que poner DataNucleus Enhancer (y dependencias) en el CLASSPATH.
008007=El "Implementation creator" no esta configurado. Debido a eso usted no puede usar "PersistenceManager.newInstance()"!
008008=El "Implementation creator" {0} esta preparado para usar.
008009=El MetaDataManager para el API "{0}" no esta registrado. Por favor compruebe que el plugin apropiado esta en el CLASSPATH
008010=Error en la creción del MetaDataManager para el API "{0}" : {1}
008011=La propiedad {0} ha sido especificada pero no podemos usarla porque la base de datos es de sólo-lectura
008012=La propiedad "{0}" tiene el valor "{1}" pero el valor no es válido. Por favor consulte la documentacion para ver la lista de valores correctos.
008013=El archivo de propiedades "{0}" leemos antes. Vamos a ignorar el archivo de propiedades "{1}"
008014=No se puede leer el archivo de propiedades "{0}"
008015=Propiedad {0} desconocida - vamos a ignorarla
008016=Cambios en la configuración no son posible despues de generar un manager de persistencia
#
# Connections
#
009000=La Connección ha sido reservado por usted y debe cerrarla antes de usar operaciones del API.
009001=La factoría de conexiones ({0}) no está soportada - debe ser un javax.sql.DataSource
009002=La factoría de connecciones "{0}" no existe o no se encuentra disponible
009003=Ya existe una conexión a la base de datos - quizas un Query siga ? La especificacion de JDO sección 12.6 dice que un PersistenceManager puede usar solamente una connección a la base de datos en un momento. Si usted quiere hacer otras operaciones, debe usar más PersistenceManagers.
#
# ObjectManager
#
010000=Object Manager "{0}" se abrió para la base de datos "{1}"
010001=Object Manager "{0}" se cerró
010002=Object Manager ya esta cerrado
010003=ObjectManager proceso internalFlush() empezado - {0} objetos sucios
010004=ObjectManager proceso internalFlush() terminado
010005=Intento de obtener un objeto nondurable en estado HOLLOW por getObjectById!
010006=No hay ningun objeto nondurable con este identidad en el cache - ¿quizas de otro Manager?
010007=Objeto con id "{0}" es manejado por otro ObjectManager
010008=Objeto no es detachado. Esta operación le hace falta un objeto en este estado
010009=Haciendo el objeto detachado : "{0}" (profundidad={1})
010010=Detachando una copia del objeto : "{0}" (profundidad={1}) : va a ser "{2}"
010011=DetachOnClose : Cerrando Manager asi que haciendo detach con todos los objetos corrientes ...
010012=DetachOnClose : detach terminado
010013=No es posible detachar el objeto "{0}" (id="{1}") al cometer como ya no existe en la base de datos. Quizas haya una clave ajena que lo ha borrado
010014=No se puede usar detachCopy() fuera de una transacción cuando haya instancias en el estado "transient" alcanzable
010015=Haciendo el objeto persistente : "{0}"
010016=Haciendo el objeto persistente (adjuntar) : "{0}"
010017=Intento de adjuntar "{0}" a persistencia pero otro objeto persistente con la misma identidad ya existe para esta transaccion!
010018=Haciendo el objeto persistente (adjuntar) : "{0}" - adjuntando para ser "{1}"
010019=Borrando el objeto de persistencia : "{0}"
010020=No fué posible borrar objetos transitorios.
010021=No fué posible borrar objetos transitorios transaccional. Identidad de objeto = {0}
010022=Haciendo el objeto transitorio : "{0}"
010023=Objeto "{0}" (id="{1}") no es transaccional
010024=No fué posible cambiar el estado de objetos entre sucio transitorio y non-transaccional
010025=No fué posible cambiar el estado de objetos entre transitorio y non-transaccional
010026=Objeto no existe
010027=El objeto con id "{0}" no ha sido encontrado
010028=No fué posible crear una identidad de objeto por una clase que es nulo!
010029=No fué posible crear una identidad de objeto por la clase "{0}" porque el tipo de clave no esta soportada ({1})
010030=Ocurrió un error durante la construcción de una instancia de Id de tipo "{0}" por la clase abstracta "{1}"
010031=Algunos objetos han fallado de commit() debido a problemas de verificación optimista.
010032=Haciendo la comprobación de "persistence-by-reachability" (commit) ...
010033=El objeto con identidad "{0}" se almacenó con una llamada a makePersistent() pero ya no esta accesible. Vamos a borrar el objeto de la base de datos.
010034=Ha terminado la comprobación de "persistence-by-reachability" (commit).
010035=Cannot perform operation since ImplementationCreator doesnt exist in the CLASSPATH (put datanucleus-enhancer.jar in the CLASSPATH).
010036=No fué posible desahuciar algunos de los objetos
010037=No fué posible refrescar algunos de los objetos
010038=No fué posible recuperar algunos de los objetos
010039=No fué posible hacer persistente algunos de los objetos
010040=No fué posible borrar algunos de los objetos
010041=No fué posible hacer transitorio algunos de los objetos
010042=No fué posible hacer transaccional algunos de los objetos
010043=No fué posible hacer non-transaccional algunos de los objetos
010044=No fué posible encontrar el objeto con identidad nulo!!

010050=Intento de empezar una transaccion optimistica pero StoreManager para este base de datos no soporte optimistic locking! Elige "datanucleus.Optimistic" como falso.
010051=Intento de persistir un objeto con datastore-identity pero StoreManager para este base de datos no soporte ese identity type
010052=Intento de persistir un objeto con application-identity pero StoreManager para este base de datos no soporte ese identity type

#
# Managed Relationships
#
013000=Manejar de relaciones : empezando
013001=Manejar de relaciones : terminado
013002=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a "{4}". Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013003=Manejar de relaciones : El objeto "{0}" tiene campo "{1}" cambiado a "{2}" pero el campo "{3}" de ese objeto ha sido cambiado a nulo. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013004=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" que ya tiene valor de "{2}" pero ya ese objeto va a relacionar con "{3}" asi que ponemos nulo en el campo
013005=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido cambiado para relacionar con este objeto, asi que cambiando nuestra relacion para estar de acuerdo
013006=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" pero ya no estan relacionados. Quitandolo del contenedor
013007=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" con el campo "{2}" del objeto "{3}" y debe estar en el contenedor pero no esta. Añadiendolo
013008=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero ese objeto ya este en estado borrado!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013009=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido añadido, pero tiene su dueño como "{3}"!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"
013010=Manejar de relaciones : El objeto "{0}" tiene una relacion bidireccional "{1}" y el objeto "{2}" ha sido borrado, pero tiene este objeto como su dueño!. Se puede quitar la prueba con "datanucleus.manageRelationshipsChecks"

#
# Transactions
#
015000=Transacción empezada para el ObjectManager {0} (optimistic={1})
015001=Haciendo commit de la transaacción para el ObjectManager {0}
015002=Haciendo rollback de la transacción para el ObjectManager {0}
015003=Transacción empezada para la connection {0}
015004=La ransacción no se pudo comenzar
015005=La ransacción no se pudo flush
015006=Haciendo commit de la transacción para la connexión {0}
015007=No se puedo hacer commit de la transacción
015008=Haciendo rollback de la transacción para la connexión {0}
015009=Transaccion ha fallado de restaurar
015010=El modo Non-transaccional Write no está soportado
015011=El modo Optimistic no está soportado
015012=Nivel de aislamiento no es válido : {0}
015013=La connexión {0} empezó para una transacción pesimista
015014=La connexión {0} terminó para una transacción pesimistac
015015=La connexión {0} empezó para una transacción optimista
015016=La connexión {0} terminó para una transacción optimista
015017=Objeto "{0}" (id="{1}") ha sido puesto en la cache transaccional
015018=Objeto "{0}" (id="{1}") puesto en la cache transaccional ya esta referenciado por id="{2}"
015019=Objeto "{0}" (id="{1}") va a ser borrado de la cache transactional
015020=Transacción es "rollback-only", asi que no se puede hacer commit en este estado.
015021=No se pudo obtener una connexión.
015022=Transacción committed en {0} ms
015023=Transacción rolled back en {0} ms
015024=El uso de transacciones de JTA necesita una datasource manejado como tiene dependencia al TransactionManager para cometer las connecciones.
015025=Ya hemos asynchronisado con la transacción de JTA, pero hemos recibido otro pedido hacerlo!
015026=Transacción de JTA pero hemos recibido un error buscando la transacción de JTA.
015027=Transacción de JTA esta marcado por rollback, quizas un timeout. Cualquier otra operación que necesita accesso a la base de datos va a fallar.
015028=Error intentando obtener el estado de la transacción de JTA!
015029=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrar el NamingService. Por favor compruebe su configuración
015030=Transacción de JTA es necesario para synchronisar con el TransactionManager de JTA, pero no era posible encontrarlo (solo apoyamos WebLogic y JBoss)
015031=Una transacción de la base de datos ha sido restaurada, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015032=La transacción ya está activo.
015033=La transacción ya está activo.
015034=La transacción está activo todavia. Debe cerrar las transacciones usando los métodos commit() o rollback().
015035=La transacción no está activo. Tiene que poner este en una transacción o usar su PersistenceManagerFactory con 'NontransactionalRead' y 'NontransactionalWrite' como 'true'
015036=Se está haciendo commit o rollback de la transacción. Esta operación no esta disponible en este momento.
015037=Una transacción de base de datos ha sido acometida, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
015038=Operation {0} failed on resource: {1}, error code {2} and transaction: {3}
015039=Running {0} operation on resource: {1}, error code {2} and transaction: {3}
015040=La transacción no está activo. Tiene que poner este en una transacción.
015041=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalRead' puesto. Usted no tiene ninguna de los dos.
015042=Imposible performar la operacion como se hace falta una transaccion activa o 'NontransactionalWrite' puesto. Usted no tiene ninguna de los dos.
015043=Este base de datos no soporte el nivel de isolacion de transacciones "{0}"

#
# Types
#
016000=Soportando el tipo de Java {0} (persistent={1}, DFG={2}, embedded={3})
016001=Soportando el tipo de Java {0} como el tipo de Java {1}
016002=Excepcion tirada en la conversion de "{0}" a un objeto del tipo "{1}"
016004=La clase de mapping "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
016005=La clase de SCO "wrapper" "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
#
# Sequence
#
017000=No hemos encontrado la secuencia "{0}". Por favor compruebe que existe en un archivo de Meta-Data.
017001=No hemos encontrado el factory-class "{0}" por la secuencia "{1}". Está en el CLASSPATH ?
017002=Ocurrió un error durante la invocacion de metodo newInstance() en el factory-class "{0}" : {1}
017003=La secuencia "{0}" ya existe y usa el generador "{1}"
017004=La secuencia "{0}" no tiene valores asignados. Por favor llame primero a "allocate(int)" para asignar los valores.
017005=La secuencia "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.
017006=Error durante el proceso obtener la conexión por la generación de valor : {0}
017007=Error durante el proceso cerrar la conexión por la generación de valor : {0}
#
# Exceptions
#
018000=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data/Annotaciones de la clase no existe o no se encuentra disponible.
018001=No hemos encontrado el Meta-Data/annotaciones para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML correcto y válido.
018002=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data de la clase no existe o no se encuentra disponible.
018003=No hemos encontrado el Meta-Data para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML para JDO correcto y válido.
018004=La clase "{0}" no es Detachable. Este significa que el MetaData de la clase no incluyo el atributo "detachable" como "true".
018005=Algunos de los objetos no son de clases que son Detachable. Este significa que el MetaData de las clases no incluyo el atributo "detachable" como "true". Las excepciones adjuntas tienen los detalles de los objetos.
018006=El objeto de tipo "{0}" esta detachado. ¡No se puede utilizar objetos detachados con esta operación!
018007=La clase persistente no tiene un Extent (definido en el Meta-Data) : {0}
018008=El campo "{0}" contiene un objeto que no esta persistente pero el campo no permite persistencia por cascada.
018009=El campo "{0}" no existe en {1} o no es persistente
018010=El campo #{0} no existe en {1} o no es persistente
019000=La clase {0} ha sido definido con el object-id class {1} que es "inner" pero no es estatica. El ObjectId class debe ser estatica si es "inner".
#
# Primary Key
#
019001=La clase {0} ha sido definido con el object-id class {1} que no es publico. El ObjectId class debe ser publico.
019002=La clase {0} ha sido definido con el object-id class {1} que no es Serializable. El ObjectId class debe ser Serializable.
019003=La clase {0} que utilisa la clase de identidad de JDO SingleFieldIdentity, pero hay mas que un campo con primary-key para la clase. Se puede elegir solo un campo como primary-key
019004=La clase {0} ha sido definido con el object-id class {1} que no tiene constructor defecto. Todos los objectId classes deben tener un constructor defecto.
019005=La clase {0} ha sido definido con el object-id class {1} que no tiene un constructor de String. Todos los objectId classes deben tener un constructor de String.
019006=La clase {0} ha sido definido con el object-id class {1} que no define el metodo toString(). Todos los objectId classes deben definir el metodo toString().
019007=La clase {0} ha sido definido con el object-id class {1} que no define el metodo hashCode(). Todos los objectId classes deben definir el metodo hashCode() para utilizar todos los campos de la clave primaria.
019008=La clase {0} ha sido definido con el object-id class {1} que no define el metodo equals(). Todos los objectId classes deben definir el metodo equals() para utilizar todos los campos de la clave primaria.
019009=La clase {0} ha sido definido con el object-id class {1} que tiene el campo {2} que no es Serializable. Todos los campos non-estaticos del objectId class deben ser Serializable.
019010=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2} que no es publico. Todos los campos non-estaticos de un objectId class deben ser publico.
019011=La clase {0} utilisa la clase de identidad {1}que tiene un campo {2}, pero el campo no existe en la clase {0}.
019012=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} que es persistence-capable. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019013=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} pero debe ser {4}. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
019014=Class {0} has been specified with an object-id class {1} which has a field {2}. The field {1}.{2} has type {3} that must be specified in the metadata /jdo/package/class/@objectid-class attribute for type {4}. e.g <class name="{4}" objectid-class="{3}"/>
019015=La clase {0} ha sido definido con el object-id class {1} que tiene {2} campos, mientras la clase ha sido definido con {3} campos en el "primary-key". El numero de campos en el objectidClass y el numero en el "primary-key" deben ser lo mismo.
019016=Invalid primary key class {0}.
020000=La clase "{0}" no tiene una tabla en la base de datos, pero esta operacion la necesita. Por favor compruebe el MetaData
020001=El campo no tiene una columna en el base de datos : {0}
020002={0} no puede ser referenciado en una expression de tabla basado en {1} porque no existe ninguna unión a su tabla, {2}

#
# Query
#
021000=Tipo de parámetro incompatible : era {0}, pero debe ser {1} o una subclase
021001=El Query de JDOQL ha vuelto más que una instancia pero "unica" esta "verdad" o hay solo aggregados asi que debe devolver una como maxima.
021002=La declaración del import no es valido : {0}
021003=La declaración del package import no es valido : {0}
021004=La declaración del class import es duplicado : {0}
021005=La clase de los imports no existe : {0}
021006=Almacenando el hecho de que {0} no fuera encontrado por {1}
021007=Los tipos de Array son illegal : {0}
021008=Hay ambiguedad en la declaración de la clase ; puede ser {0} o {1}

021010=La clase {0} ha sido resuelto a {1}. Usted no la puso completamente en el Query y por eso podria evitar en look-up (y mejorar el rendimiento) si la ponga con nombre de paquete etc.
021011=Intento de invocar el metodo "{0}()" del objeto de tipo "{1}" - no lo apoyamos con este base de datos
021012={1} Query : Procesando la clausula "{0}" con evaluacion en memoria (clausula = "{2}")
021013=El Manager del Query esta cerrado!
021014=Esta Query no se puede cambiar. No puede cambiar su estructura.
021015=Query contiene nombre de una clase "{0}" (clase de candidato, clase de resultado, parametro, o variable) pero no esta resuelto. Por favor, compruebe el nombre y los imports.
021017=Query no tiene un Manager

021018=La ejecución del query "{0}" no ha completado antes que el timeout de {1}ms
021019=El query "{0}" empiece en un su propio hilo con el timeout de {1}ms
021020=El query "{0}" ha sido cancelado
021021=Un error ha ocurrido durante la ejecución del query "{0}"
021022=El query "{0}" empiece en un su propio hilo sin timeout

021027=Query tiene que borrar objetos, pero hay un orden. No se puede poner el orden si es para borrar instancias.
021028=Query tiene que borrar objetos, pero hay un grupo. No se puede poner el grupo si es para borrar instancias.
021029=Query tiene que borrar objetos, pero el resultado existe. No se puede poner el resultado si es para borrar instancias.
021030=Query tiene que borrar objetos, pero la clase de resultado existe. No se puede poner la clase de resultado si es para borrar instancias.
021031=Query tiene que borrar objetos, pero tiene alcance de resultado. No se puede poner el alcance de resultado si es para borrar instancias.
021032=Query tiene "unique", pero el resultado contiene más que un objeto. No se puede poner "unique" si hay más que un objeto por ser borrado.
021043=Error con la extracción de resultados por el Query "{0}"

021044=Query de {0} : Compilación de "{1}"
021045=Query de {0} : Tiempo de compilar = {1} ms
021046=Query de {0} : Ejecucion de "{1}" ...
021047=Error en la ejecucion de Query de {0} - "{1}" : {2}.
021048=No hay una clase de candidato por el Query de {0}
021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021050=El filtro de Query "{1}" no da un resultado de boolean
021051=La expresión de "HAVING" "{0}" no es valido. Debe ser una expresión Boolean.

021053=La clase "{0}" en una expresión (cast) no existe. Por favor compruebe que la clase esta en el CLASSPATH y esta en los imports del Query.

021054=El Query de {0} contiene una expresión invalida
021055=Query tiene algunas parametros declarados ("{0}"), pero hay por lo menos un parametro implicito ("{1}"). Es invalido. Usted debe declarar todos los parametros (explicito), o usar todos los parametros con un prefix :.
021056=Query tiene un parámetro implicito "{0}" (en posición {1}) ¡pero no había un valor disponible para esta posición!

021057=El uso de "new" en {0} debe seguir con el nombre de la clase, pero {1} no existe. Por favor, compruebe la lista de "imports".
021058=El uso de "new" en {0} debe seguir con el nombre de la clase y los argumentos del constructor pero esta incorrecta en "{1}".

021049=No era posible encontrar el campo "{0}" en la clase de candidato. Es posible que este campo es un campo en una subclase, pero es illegal usar campos de las subclases directamente.
021060=Error conectando el variable "{0}" a "{1}" como estaba conectado a "{2}" antes.
021061=El variable "{0}" no esta conectado al Query de JDOQL.
021064=The range {0} expression accepts only Literal values. Either define it as parameter or a literal. The current value is {1}.
021065=The range {0} expression expects a number, but it currently is {1}.
021066=No era posible encontrar la clase "{0}". Por favor, compruebe que la clase existe en el CLASSPATH.
021068=El parametro de Query ("{0}") esta conectado a otro Manager. Es imposible usar este Query asi.
021069=El "ORDER BY" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "ORDER BY" tiene que estar tambien en el "GROUP BY".
021070=El resultado tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el resultado tiene que estar tambien en el "GROUP BY".
021071=El "HAVING" tiene una expresión de campo "{0}" que no existe en el "GROUP BY". Cualquier campo referenciado en el "HAVING" tiene que estar tambien en el "GROUP BY".
021051=La expresión de "HAVING" "{0}" no es valido. Debe ser una expresión Boolean.
021072=Collección de candidatos esta vacia!
021073=Extent de candidatos esta vacia!
021074=Query de {0} : Tiempo de ejecutar = {1} ms
021079=Query "{0}" de lenguaje "{1}" existe, por eso utilizamos la compilacion general de antes.
021080=Query "{0}" de lenguaje "{1}" para la base de datos "{2}" existe, por eso utilizamos la compilacion de datastore de antes

# Query : Parameters/Variables
021101=Query tiene una lista de parametros que esta incorrecta "{0}"
021102=Query tiene un parametro "{0}" que esta incorrecta
021103=Query tiene dos o mas parametros con nombre "{0}"
021104=Query tiene una lista de variables que esta incorrecta "{0}"
021105=Query tiene un variable "{0}" que esta incorrecta
021106=Query tiene un variable "{0}" que es lo mismo que un parametro
021107=Query tiene dos o mas variables con nombre "{0}"
021108=Query hace falta {0} parametros, pero tiene {1}.
021109=The parameter {0} expected the argument value of primitive type {1}.
021110=El Query de {0} hace falta un parametro "{1}" pero no esta
021111=Query tiene algunas variables declarados ("{0}"), pero hay por lo menos un variable implicito ("{1}"). Es invalido. Usted debe declarar todos los variables explicito, o usar todos los variables como implicito.
021112=Query contiene un parametro "{0}" pero no hay ningun valor especificado al ejecutar el Query!
021113=Query tiene un valor por el parametro "{0}" pero este parametro no existe en el Query!
021114=Query tiene parametro "{0}" como un {1} pero esta comparado con un {2}. Los valores de parametros deben ser consistente con lo que se compare.
021115=Query tiene un subquery pero no hay declaracion de variables! Un subquery tiene que pasar su valor al Query principal por un variable
021116=Query tiene el parametro "{0}" provisto al ejecucion pero este query no lo utiliza!

# Query : Result
021201=El Query va a volver con mas que un campo pero la clase de resultado es de un tipo simple ({0}). Son inconsistentes.
021202=El Query va a volver con un campo pero no es de la clase de resultado ({0}) : es {1}
021203=El Query tenia que devolver objetos de tipo "{0}" pero era imposible. Por favor compruebe que esta clase esta corecta por JDO.
021204=El Query tenia que devolver objetos de tipo "{0}" pero era imposible poner el valor al campo "{1}"  tipo "{2}". El campo debe tener un metodo publico set/put o ser publico.
021205=El Query tenia que devolver objetos de tipo "{0}" pero era imposible crear nueva instancia de este tipo! La clase de resultado necesita un constructor sin argumentos.
021206=La clase de resultado "{0}" no tiene un constructor con arguments de tipos {1}
021207=La clase de resultado "{0}" no tiene un metodo publico "void {1}({2})".
021208=La clase de resultado"{0}" no tiene un metodo publico "void {1}(Object, Object)".
021209=La clase de resultado "{0}" no tiene un campo publico "{1}"
021210=La clase de resultado no permite nombres de campos en mayusculos o menusculos; tiene que ser escrito corecto. Por ejemplo, el campo "{0}" esta mal escrito.
021211=El query tiene campo de resultado "{0}" de tipo "{1}" pero el tipo en la clase de resultado es "{2}"!
021212=El query tiene clase de resultado "{0}" pero no hay ninguna manera de poner el campo "{1}"!

# Query Cache
021500=Cache de Query "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
021501=Cache de Query "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
021502=Cache de Query del tipo "{0}" inicializada

#
# Api Adapter
#
022000=Error : Un error ocurrio cuando creando un adaptador "{0}" : {1}
#
# SCO
#
023000=El tipo de parámetro solicitado por el campo "{0}" : era {1} pero debe ser {2}
023001=El campo {0} no puede ser nulo en objeto "{1}"
023002=El contenedor (Collection/Map) no es preguntable como no tiene dueño que es un objeto de primera clase
023003=Creado SCO wrapper por objeto "{0}" campo "{1}" con {2} valores, con las opciones="{3}"
023004=El objeto "{0}" campo "{1}" ha sido reemplazado por un SCO wrapper de tipo "{2}" {3}
023005=El objeto "{0}" campo "{1}" enviando cambios del contenedor de SCO a la base de datos
023006=El objeto "{0}" campo "{1}" obteniendo los contenidos al contenedor de SCO de la base de datos
023007=El objeto "{0}" campo "{1}" va a ser inicializado por un contenedor con {2} valores
023008=El objeto "{0}" campo "{1}" va a ser cambiado por un conteneder con {2} valores
023009=Es imposible persistir el objeto "{0}" como esta manejado por otro Object Manager
023010={0} no es un tipo valido de SCO por campo {1}, deb ser compatible con {2}
# needs updating
023011=La clase {0} no es apoyado como objeto de clase segundo (SCO)
023012=El campo "{0}" debe usar un comparator de clase "{1}" pero esa clase no existe en el CLASSPATH. Por favor compruebe el nombre de la clase de comparator.
023013=Execución del metodo "{0}" en el campo "{1}" ha causado un error : {2}
#
# Plugin
#
024000=File {0} doesn't exist. Check your path or classpath.
024001=Error reading plug-in file {0} : {1}
024002=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
024003=Loading extension points from plug-in file {0}.
024004=Loading extensions from plug-in file {0}.
024005=Plugin Registry "{0}" no existe. Usando registry de DataNucleus
024006=Plugin Registry "{0}" no existe. Usando registry de DataNucleus. Reason : {1}.
024007=Error en la registración del Bundle como el URL al MANIFEST.MF es nulo
024008=Error en leer el manifest "{0}"
024009=El plugin (Bundle) "{0}" ya esta registrado. Por favor compruebe que usted no tiene otras versiones del mismo plugin en el CLASSPATH. El URL "{1}" esta registrado, y intenta registra otro al URL "{2}."
024010=Error en la creación del URL para el plugin MANIFEST "{0}"
024011=Error en leer el MANIFEST.MF for "{0}"
024012=No se puede encontrar el fichero MANIFEST.MF para el plugin "{0}". Vamos a ignorarlo
024013=Bundle "{0}" tiene una dependencia opcional a "{1}" pero no se puede resolverla
024014=Bundle "{0}" se hace falta "{1}" pero no se puede resolverla
024015=Bundle "{0}" se hace falta "{1}" versión "{2}" pero ese bundle tiene versión "{3}" que esta fuera de los versiones aceptadas.
024016=Error en la creacion del DocumentBuilder : {0}
#
# CallbackHandler
#
025000=Error : Un error ocurrio cuando creando un CallbackHandler "{0}" : {1}
025001=Una excepcion ha sido tirado por el callback del usuario "{0}".
#
# StateManager
#
026000=No hay bastante acceso a org.datanucleus.*
026001=Desconectando del clono {0} de {1}
026002=El campo {0} de la clase {1} no existe
026003=Cambiar el StateManager da un error
026004=Desconectar el StateManager da un error
026005=Vaciando el StateManager de {0}
026006=El metodo no es apoyado
026007=No es posible compartir SCO's con dueños; objeto doñado por campo {0} del objeto {1}
026008=Recurrente llamada a deletePersistent()
026009=Recurrente llamada a flush()
026010=Objeto tiene el estado ´sucio´´ pero ¡no hay campos sucios!
026011=Disconectando {0} de {1}
026012=No puede persistir la clase {0}
026013=Objeto no existe (identidad="{0}")
026014=La clase "{0}" del objeto con id "{0}" na ha sido encontrado
026015=La clase {0} no esta ! Por favor, comprueba usted que la clase existe en el CLASSPATH.
026016=The primary-key field {0} is null.
026017=Un objeto de la clase "{0}" usa SingleFieldIdentity con el campo "{1}" pero el campo no tiene ningun valor! Usted debe poner un valor, o usa "value-strategy" con este campo.
026018=La clase "{0}" no ha sido registrada. Por favor compruebe que esta analizada.
026019=No podemos crear una instancia de la clase "{0}". Si es "abstract", usted tiene que comprobar que no hay una fila por esa clase en la base de datos sin una fila en la tabla de una subclase.
026020=El campo "{0}" tiene value-strategy de "{1}" pero el tipo del campo no esta correcta usarlo.
026021=El campo "{0}" del objeto "{1}" ha sido registrado para actualización cuando su valor PC esta en la base de datos.
026022=Vamos a actualizar el valor del campo "{0}" del objeto "{1} como su valor PC ya esta en la base de datos.
026023=No podemos "detach" al objeto de tipo "{0}" y con identidad "{1}" porque ha sido borrado!
026024=No podemos "detach" el objeto de tipo "{0}" y con identidad "{1}" porque ya es "detached"!
026025=El "detach" del objeto de tipo "{0}" y con identidad "{1}" ha fallado. Por favor, compruebe el Log para alguna detalle.
026026=Vamos a borrar el objeto "{0}" porque esta el valor en un campo ({1}) donde el valor has sido anulado y el campo es delete-dependent.
026027=Una transition ilegal "{0}" ha sido intentado desde el estado "{1}", sm = "{2}"
026028=El objeto "{0}" ha sido marcado para persistir pero vamos a persistir a la base de datos mas tarde debido a transacción optimistic o "delayDatastoreOperationsUntilCommit"
026029=El objeto "{0}" (id="{1}") va a tener el valor en el campo "{2}" cambiado por un SCO wrapper
026030=El objeto "{0}" (id="{1}") va a tener el SCO wrapper en el campo "{2}" cambiado por el valor026031=Object "{0}" (id="{1}") is to be detached (using DetachAllOnCommit?) but is not detachable, so being made transient
026031=El objeto "{0}" (id="{1}") va a ser detachado (con la opcion DetachAllOnCommit?) pero no es detachable, por eso vamos a hacerlo transient
026032=El objeto "{0}" (id="{1}") tiene una valor cargado en campo {2} que esta fuera del FetchPlan. Descargandolo.
026033=El objeto "{0}" (id="{1}") va a tener los campos siguientes cargados del objeto de L2 cache : {2}
#
# LifeCycle states
#
027000=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027001=No se puede escribir los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalWrite=true'.
027002=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
027003=No es posible cambiar el estado del objeto a nontransaccional como es nuevo, borrado y no esta comitido
027004=No es posible cambiar el estado del objeto a transitorio como es nuevo, borrado y no esta comitido
027005=No es posible leer campos de un objeto borrado
027006=No es posible escribir campos de un objeto borrado
027007=No es posible cambiar el estado del objeto a nontransaccional como esta borrado
027008=No es posible cambiar el estado del objeto a transitorio como esta borrado
027009=No es posible leer campos de un objeto borrado
027010=No es posible escribir campos de un objeto borrado
027011=No es posible cambiar el estado del objeto a nontransaccional como es sucio
027012=No es posible cambiar el estado del objeto a transitorio como es sucio
027013=No es posible cambiar el estado del objeto a nontransaccional como no es nuevo y no esta comitido
027014=No es posible cambiar el estado del objeto a transitorio como es nuevo y no esta comitido
027015=El campo no esta copiado al objeto "detached". Usted tiene que añadirlo al FetchPlan y "detach" el objeto otra vez.
027016=Objeto "{0}" (id="{1}") tiene cambio de lifeycle : "{2}"->"{3}"
#
# XML Parser
#
028000=XML Entity Public="{0}" System="{1}" : con source local "{2}"
028001=XML Entity Public="{0}" System="{1}
028002=resolveEntity({0}, {1}) no existe
028003=resolveEntity({0}, {1}) ha fallado!
#
# SingleFieldIdentity
#
029000=No era posible construir una identidad de SingleFieldIdentity de tipo "{0}" porque la clase dado es nulo
029001=El tipo de identidad para construir una identidad de SingleFieldIdentity para la clase "{0}" es nulo
029002=El tipo de identidad ("{0}") dado para construir una identidad de SingleFieldIdentity para la clase "{1}" no es valido.
029003=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" para la clase "{1}" es nulo.
029004=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" de la clase "{1}" es de un tipo invalido ("{2}") - debe ser "{3}".
#
# Utils
#
030000=Todavia espero el read lock por {0}
030001=Ya el Thread tiene un read lock
030002=Todavia espero el write lock por {0}
030003=El formato de Timestamp no esta mal: "{0}" - debe ser yyyy-mm-dd hh:mm:ss.fffffffff
030004=Un constructor de la clase {0} no existe, parametros {1} 
030005=Error cuando intentando usar la clase {0}
030006=Error intentando crear un objeto de la clase {0}
030007=Excepcion tirado por constructor por {0}, {1}
#
# RDBMS Views/Macros
#
031000=Incomparable puntales para el macro de interrogacion: {0}
031001=Incomparable punto de interrogacion para el macro de parametro: {0}
031002=No puede parsar macro de identificacion: {0}
031003=Hay una dependencia circular entre las visiones

#
# Store Manager
#
032000=No hay un StoreManager disponible : {0}
032001=Va a manjejar la persistencia de {0}
032002=Desmanejando la persistencia de todas las clases
032003=Manejando la persistencia de {0} porque era manejado antes

032004=Intenta de poner objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032005=Intenta de poner objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032006=Intenta de cambiar objeto "{0}" en una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032007=Intenta de cambiar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032008=Intenta de borrar objeto "{0}" de una base de datos que es para leer. Usted ha puesto esta base de datos "read-only" con la propiedad de PersistenceManagerFactory "org.datanucleus.readOnlyDatastore". Debe quitar esta propiedad si quiere poner objetos alli.
032009=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.
032010=Intenta de borrar objeto "{0}" dependiente de objeto en una base de datos que es para leer
032011=Intenta de borrar objeto "{0}" en una base de datos que es para leer. Vamos a ignorarlo.

032012=La clase "{0}" es "embedded-only" asi que no tiene su propia tabla.
032013=La clase "{0}" usa la estrategia "subclass-table" y no hay una subclase o superclase que tiene una tabla.
032014=La clase "{0}" usa la estrategia {1} y no hemos encontrado una tabla para persistirla.
032015=Intenta obtener el nombre de la tabla de base de datos por una clase nula !

032013=La clase {0} usa estrategia de "subclass-table" pero ningun subclase tiene una tabla definida.

032016=Objeto "{0}" (id="{1}") ha sido cambiado en la base de datos después de la ultima leer. Base de datos tiene version "{2}" pero la transacción tiene version "{3}"
032017=La clase "{0}" tiene estrategia de versiones de "{1}" pero JPOA no la apoya ahora mismo. Por favor compruebe la documentación para las estrategias que apoyamos.

032018=Registrado la factoria de connecciones transaccionales bajo el nombre "{0}"
032019=Registrado la factoria de connecciones nontransaccionales bajo el nombre "{0}"

032020=StoreManager : "{0}" con el URL "{1}" - opciones={2}, {3}

#
# Extent
#
033000=No se puede crear el Extent porque tiene que dar el nombre de la clase.
033001=No se puede crear el Extent de la clase "{0}" porque no hay Meta-Data disponible para esa clase.
033002=El Extent de {0} incluso los subclases={1}
033003=Query sobre Extent nunca va a dar resultado sin subclases : extent= {0}, clase={1}

#
# Auto Starter
#
034000=Error en la inicialisación de DataNucleus : Una clase "{0}" estaba en la lista de persistencia de este esquema pero no la existe. Quizas es de otra aplicación de DataNucleus usando la misma esquema, o has cambiado los nombres de las clases.
034001=Borrando la clase {0} de la lista de clases manejadas
034002=Unknown Error during auto starter execution. : {0}
034003=Illegal state of AutoStart, disabling it. To enable it, resolve earlier errors.
034004=Error en la inicialisación de DataNucleus: una clase "{0}" estaba en la lista de persistencia de este esquema pero ya no tiene MetaData disponible.

034100=Mecanismo de AutoStart con clases. Tiene que poner una lista de clases en la construcción del PMF.
034150=Mecanismo de AutoStart con MetaData. Tiene que poner una lista de archivos de MetaData en la construcción del PMF.

034200=Mecanismo de AutoStart de XML. Almacena su definición en un fichero de XML
034201=El fichero de XML AutoStarter {0} no existe. Creandolo ...
034202=Error leer el fichero de XML AutoStart {0} : {1}
034203=Error escribir el fichero de XML AutoStart {0} : {1}
034204=resolveEntity({0}, {1})

#
# Store Data
#
035000=El MetaData no puede ser nulo : tabla = {0}
035001=La tabla no puede ser nulo
035002=Clase : {0}
035003=Campo : {0}
035004=Clase : {0} [Tabla : {1}, Estrategia de heredar : {2}]
035005=Campo : {0} [Tabla : {1}]

#
# Datastore Adapter
#
036000=El constructor {0}(ClassBaseTable,int) no existe
036001=Campos del tipo {0} no estan apoyados
036002=Puede usa {0} con un campo persistence-capable solamente
036003=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL Expressions
#
037000=No se puede navegar el campo "{0}" en "{1}". Debe hacer un Cast este Interface a un tipo concreto y intentarlo otra vez.
037001=Query tiene una referencia al campo "{0}", pero la tabla del Query "{1}" no tiene ninguna columna por este campo
037002=Query tiene una referencia al campo "{0}" pero el campo "{1}" no existe en el objeto del campo "{2}"
037003=Query tiene comparacion a un objeto "{0}" que no tiene identidad de JDO - quizas el objeto sea transient o embedded. Siempre devuelve nada.
037004=Query tiene comparacion con una collecion qu no es nulo. DataNucleus no lo apoya.

037005=Query tiene una referencia al campo "{0}" pero la clase usa "subclass-table" estrategia de heredar y no hay ninguna subclase de esa clase. No podemos crear un Query de JDOQL.
037006=Query tiene una referencia al campo "{0}" per la clase usa "subclass-table" estrategia de heredar. DataNucleus apoya una relacion 1-1 con "subclass-table" si hay una subclase sola, pero aqui hay mas! Vamos a usar "{1}"
037007=Intenta de comparar el "instanceof" de un objeto con una expressión de tipo "{0}". JDOQL solo permita la comparación con una clase.

037008=Intenta de usar el método "{0}" de la clase "{1}", pero el método no es public static final. No lo apoyamos en JDOQL.
037009=Intenta de usar el método "{0}" de la clase "{1}", ¡pero no lo existe!
037010=El operador de JDOQL "instanceof" tiene clase "{0}", pero no la encontramos. Por favor, compruebe que la clase esta puesta correctamente.

037011=Intenta de invocar la expresión "{0}" con un argumento que no es numerico. Esta expresión acepta solo argumentos de tipo numerico.
037012=Intenta de usar "DISTINCT" con la expresión "{0}". No es posible con esta función.

037013=Query de JDOQL tiene una expresión para construir un objeto de la clase "{0}" con un constructor que no existe! Por favor, corrigelo.
037014=Intenta de crear un objeto nuevo usando un constructor con "{0}" valores pero necesita "{1}"
037015=Error en la creación de un objeto nuevo de "{0}" : {1}

#
# OID
#
038000=El valor del OID no es valido : {0}
038001=Identidad "{0}" puesto a la clase {1}, pero el tipo de object-id no esta correcta.
038002=Valor generado para el campo "{0}" con estrategia="{1}" (Generador="{2}") : valor={3}
038003=Identidad generado para el campo {0}, id : {1} es incorrecto
038004=No hay ningun generador de valor para la estrategia "{0}" para este base de datos. Por favor, lee en la documentación sobre las estrategias que esta apoyado para este base de datos.
038005=El campo "{0}" ha sido especificado usar un TableGenerator pero no hay uno con nombre "{1}"
038006=El campo "{0}" ha sido especificado usar un SequenceGenerator pero no hay uno con nombre "{1}"

#
# Value Generators
#
040000=Era imposible crear un generador de identidades de tipo "{0}" : {1}
040001=Creando instancia de ValueGenerator de tipo "{0}" para "{1}"

040002=El repositorio de IDs es invalido
040003=Hemos encontrado un error en la allocación de un block de IDs : {0}
040004=Hemos reservado un bloque de {0} valores
040005=Creando repositorio de IDs en la base de datos ...
040006=El valor de "key-cache-size" ({0}) es invalido
040007=El valor de "sequence" ({0}) es invalido
040008=Hemos encontrado un error en la allocación de IDs : {0}
040009=El generador "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.

#
# Mapping
#
041000=El tipo de Java {0} no tiene una clase disponible para convertirlo en DataNucleus.
041001=El campo "{0}" con tipo de Java {1} no tiene una clase disponible para convertirlo en DataNucleus.
041002=El camp "{0}" con tipo de Java {1} que es "embedded" no tiene una clase disponible para convertirlo en DataNucleus.
041003=El campo "{0}" es una Collección o Mapa "embedded", pero DataNucleus no lo apoya.

041004=De alguna manera {0}.{1}() estaba llamado, pero debiera ser imposible
041005=De alguna manera {0}.{1}() del mapping del campo "{2}" estaba llamado, pero debiera ser imposible

041006=El Constructor ({0},{1}) no existe por el tipo de Mapping {2}
041007=El Constructor ({0},{1},{2}) no existe por el tipo de Mapping {3}
041009=La generación del nuevo tipo de Mapping {0} ha fallada : {1}
041010=La generación del nuevo tipo de Mapping {0} por la tabla {1}, field {2} ha fallada : {3}
041011=Constructor {0}(ClassTable, int) no existe

041012=Puede usa {0} con un campo persistence-capable solamente
041013=El fichero plugin.xml tiene una clase de datastore-mapping de "{0}" pero no la existe

041014=El campo "{0}" tiene "mapping-class" de "{1}" pero esa clase no existe! Por favor, compruebela y empezar de nuevo.

041015=No es posible fijar el campo a un objeto de otro PersistenceManager
041016=Objeto no es PersistenceCapable. Objeto clase = {0}, valor = {1}
041017=No es posible fijar la identidad de Application. Parámetro = {0}

041018=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo "{3}" de ese objeto no tiene valor; DataNucleus va a ponerlo en el objeto directamente.
041019=El objeto "{0}" tiene campo "{1}" con valor de "{2}" pero vamos a borrar ese objeto asi que ponemos nulo en el campo.
041020=El objeto "{0}" tiene campo "{1}" con relacion bidireccional 1-1 a "{2}" pero el campo de ese objeto tiene relacion a "{3}"!
041021=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collección "{3}" no contiene este objeto; lo vamos a añadir
041022=El objeto "{0}" tiene campo "{1}" con relacion bidirectional N-1 a "{2}" pero la collección "{3}" no contiene este objeto.

041023=¡El campo "{0}" no tiene MetaData por un contenedor (collection/map/array) !
041024=Error un la creación de la clase "{0}" : {1}
041025=Es imposible usar un Query con un campo serializado ("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no serializado.

041026=Es imposible usar un Query con un campo de array almacenado en una columna("{0}"). Usted tiene que cambiar el Query, o cambiar el campo para ser no almacenado asi.

041027=No puede poner el parametro de BigInteger : valor = {0}
041028=No puede obtener el resultado de BigInteger : param = {0}
041029=No puede poner el parametro de BigDecimal : valor = {0}
041030=No puede obtener el resultado de BigDecimal : param = {0}

041031=No puede poner el parametro de Object : valor = {0}
041032=No puede obtener el resultado de Object : param = {0}

041033=No puede obtener el resultado de URL : param = {0}, valor = {1}

041034=Obtuvo objeto con OID "{0}"
041035=No era posible obtener el OID del objeto

041036=Error creating AID of type {0} : exception is {1}
041037=Error creating AID of type {0}, field {1}, value {2} : exception is {3}
041038=La columna de Primary Key "{0}" de la tabla "{1}" no esta designada
041039=¡No podemos crear una identidad de SingleFieldIdentity porque la llave obtenido de la base de datos es nulo!

041040=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como serializados.
041041=El campo "{0}" esta serializado. DataNucleus no apoya la persistencia de campos de Interface como "embedded".

041042=El campo "{0}" esta "embedded". DataNucleus no apoya la persistencia de campos de Object como "embedded".
041043=El campo "{0}" esta Object (non-serializado). DataNucleus no apoya la persistencia de campos de Object que no estan serializados.

041044=El campo "{0}" es de referencia (interface/Object) de tipo "{1}" pero DataNucleus no puede asignar el campo al valor de tipo "{2}". Solo puede asignar el campo a un valor especificado por el atributo "implementation-classes".

#
# Datastore Mapping
#
041045=resolveEntity({0}, {1})
041046=¡Los mappings datastore están en el fichero "{0}", pero el fichero no existe!
041047=Los mappings datastore están en el fichero "{0}" pero había un error leerlo : {1}
041048=La clase de mapping datastore "{0}" no está. Por favor, compruebe la especificación de clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
041049=Datastore Mapping mappings have been defined to be in file "{0}" yet this file can't be found in the classpath.

#
# JDOQL
#
042000=No se puede usar Query con Extent de la clase {0}
042001=No hay una clase de candidato por el Query de JDOQL
042002=El filtro de Query de JDOQL "{0}" no da un resultado de boolean
042003=El orden de Query de JDOQL "{0}" contiene una expresión que no esta corecta
042004=El orden de Query de JDOQL "{0}" contiene una dirección que no esta corecta. Debe ser "ascending", "descending", "asc", "desc".
042005=El Query de JDOQL incluye un parametro "{0}"pero no hay una declaración de este en la lista de parametros.
042006=El Query de JDOQL hace falta {0} parametros, pero hay solamente {1}
042007=Error usando Query de JDOQL "{0}" : {1}.
042009=El Query contiene la identificación "{0}", pero este es una palabra clave de JDOQL. El Query no es valido.
042008=El query ("{0}") tiene operador de assignar ("=") pero no existe en JDOQL. ¿La intención era usar el operador '==' para comparar dos objetos?

042010=JDOQL Single-String de "{0}"
042011=El Query contiene una palabra clave de JDOQL ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JDOQL.
042012=JDOQL Single-String Query tiene que empezar con SELECT
042013=JDOQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
042014=JDOQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
042015=JDOQL Single-String expects the keyword "{0}" after the keyword "{1}"
042016=JDOQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
042017=JDOQL Single-String Query tiena una clausula de subquery pero no cierre el parentesis

#
# JPQL
#
043000=JPQL Single-String de "{0}"
043001=El Query de JPQL contiene una palabra clave ("{0}") pero no esta en su debido posición. Usted puede poner las palabras claves en una orden definido en la especificación de JPQL.
043002=JPQL Single-String Query tiene que empezar con SELECT/UPDATE/DELETE
043003=JPQL Single-String Query tiene la palabra clave "{0}" pero es illegal con "{1}" después.
043004=JPQL Single-String Query tiene la palabra clave "{0}" pero no tiene valor. Debe tener "{1}" despues de "{0}".
043005=JPQL Single-String expects the keyword "{0}" after the keyword "{1}"
043006=JPQL Single-String Query tiene clase "{0}" pero no existe. Por favor compruebe que la clase esta en el CLASSPATH
043007=JPQL UPDATE/DELETE query no puede tener una clausula de GROUP BY
043008=JPQL UPDATE/DELETE query no puede tener una clausula de HAVING
043009=JPQL UPDATE/DELETE query no puede tener una clausula de ORDER BY
043010=JPQL UPDATE Query no tiene una clausula de UPDATE! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"
043011=JPQL UPDATE Query tiene clausula de UPDATE pero no hay SET! Query debe ser como "UPDATE Entity e SET e.param = new_value WHERE [where-clause]"

#
# MetaData
#
044001=MetaData para el campo/propiedad "{0}" tiene atributo "{1}" con valor "{2}" pero acepta "{3}"
044002=MetaData extension "{0}" acepta valores de "{1}" pero tiene valor de "{2}"!
044003=Campo/propiedad "{0}" tiene una collección pero no hay ningun tipo de elemento en el MetaData ni es posible inferirlo por generics, usamos Object
044004=Campo/propiedad "{0}" tiene un mapa pero no hay ningun tipo de clave-valor en el MetaData ni es posible inferirlos por generics, usamos Object

044005=MetaData Management : Carga de Metadata de los archivos de metadata "{0}" ...
044006=MetaData Management : Carga de Metadata de las clases "{0}" ...
044007=MetaData Management : Carga de Metadata del persistence-unit "{0}" ...
044008=MetaData Management : Carga de Metadata del usuario ...
044009=MetaData Management : Carga de Metadata del jar "{0}" ...
044010=MetaData Management : Carga de Metadata ya ha terminado


044013=MetaData Management : Inicialisando con los archivos de MetaData y clases
044014=MetaData Management : Inicialisación con los archivos de MetaData y clases ya ha terminado
044015=El archivo de MetaData "{0}" no contiene MetaData valido
044016=Hemos encontrado errores durante el proceso de leer los archivos de MetaData y clases. Compruebe por favor, las excepciones adjuntados
044017=La clase "{0}" no tiene MetaData o annotaciones.

044018=Populación del MetaData ...
044019=Inicialisación del MetaData ...
044020=Hemos encontrado errores durante la inicialisación de MetaData. Compruebe por favor, las excepciones adjuntados

044021=MetaData Management : Inicialisando con el persistence-unit "{0}"
044022=MetaData Management : Inicialisation con el persistence-unit "{0}" ya ha terminado
044023=Hemos encontrado errores durante el proceso de leer el MetaData del persistence-unit "{0}". Compruebe por favor, las excepciones adjuntados

044026=Clase "{0}" descubierto para ser parte del persistence-unit "{1}"; cargandolo
044027=El Persistence-Unit "{0}" contiene una referencia a mapping-file "{1}" pero era imposible leerlo - {2}
044028=El plugin de MetaData handler "{0}" no existe en el CLASSPATH. Por favor compruebe el CLASSPATH y la especificaión de plugin.
044029=Error creando handler del tipo "{0}" para analizar el MetaData : {1}
044030=Analizando el MetaData "{0}" con handler "{1}" (validar="{2}")

044031=¡Intenta de analizar un archivo que era nulo!
044032=Error en abrir el archivo de Meta-Data "{0}"
044033=No puede leer Meta-Data input "{0}"

044034=Empezando a analizar el elemento "{0}" (profundidad="{1}")
044035=Terminando a analizar el elemento "{0}" (profundidad="{1}")
044036=El tag "{0}" no puede tener el tag padre "{1}" : debe ser {2}
044037=El tag es desconocido : "{0}"
044038=Error en el analizo del archivo "{0}" a la linea {1} : {2} - Por favor compruebe el DTD y la validad de este MetaData.
044039=Error en el analizo del archivo "{0}" a la linea {1}, columna {2} : {3} - Por favor compruebe el DTD y la validad de este MetaData.
044040=Error en el analizo del archivo "{0}" tiene causa {1}
044041=A value is expected in the attribute "{0}" for "{1}" in element "{2}". 

044042=Un error ha ocurrido durante el analisis de <"{0}"> dentro de "{1}" para el URI "{2}"

044043=Registrando la clase "{0}" no tener Meta-Data
044044=Deregistrando la clase "{0}" no tener Meta-Data - ya vamos a añadir el Meta-Data
044045=El archivo "{0}" contiene metadata de tipo "{1}" pero debe contener del tipo "{2}". Vamos a ignorarlo
044046=No hemos encontrado ningun archivo "persistence.xml" en el CLASSPATH. Debes poner esos ficheros en la carpeta META-INF/ de los JARs.
044047=No hemos encontrado el Persistence-Unit "{0}" en los archivos "persistence.xml" disponibles.

044048=No hemos encontrado el MetaData del tipo "{0}" por la clase "{1}"
044049=No encontramos el MetaData del tipo "{0}" por la clase "{1}" en {2}
044050=No encontramos el MetaData por la query {0} en {1}
044051=No encontramos el MetaData por la secuencia {0} en {1}
044052=El MetaData del tipo "{0}" por la clase "{1}" sera {2}
044053=El MetaData por la query {0} sera {1}
044054=El MetaData por la secuencia {0} sera {1}
044055=El analizo del archivo de MetaData {0} falló
044056=El archivo "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044057=The package name in empty in MetaData file {1}.
044058=The package {0} has an empty MetaData specified for a class name. Please check the file {1}.
044059=Encontro el Meta-Data de la clase {0} pero la clase no esta analizado! Por favor, debes analizar la clase antes de usar DataNucleus.
044060=Añadiendo el Meta-Data por el campo {0} de la clase {1} como no estaba en la definición de Meta-Data.
044061=El elemento de Meta-Data "class" por package {0} necesita un 'name' attributo.
044062=El campo "{0} en la clase {1} hemos hecho non-persistente como una propiedad de persistencia con el mismo nombre existe

044063=La clase "{0}" esta especificada como PersistenceCapable pero es Inner y no es estatico. Clases asi no pueden ser PersistenceCapable.

044064=La clase {0} va a usar "application identity" pero no hay "objectid-class" en la definición. DataNucleus va a usar to {1}
044065=La clase {0} va a usar "application identity", no hay "objectid-class" en la definición, pero hay {1} campos de primary-key. No podemos usar SingleFieldIdentity.
044066=La clase {0} va a usar "application-identity", no hay "objectid-class" y hay un campo de PK , pero el campo es de un tipo invalido {1} por SingleFieldIdentity. Puede usar los tipos short, Short, int, Integer, long, Long, byte, Byte, char, Character, o String.

044067=No hay un class loader especificado por cargar las classes del MetaData de class {0}. Usando el default ClassLoader.
044068=No puede popular la clase {0} como es populado
044069=El Meta-Data no ha sido inicializado por la clase {0}.
044070=El Meta-Data no ha sido populado por la clase {0}.
044071=¡La clase {0} tiene campo {1} definido en el MetaData, pero este campo no existe en la clase!
044072=¡La clase {0} tiene metodo {1} definido en el MetaData, pero este metodo no existe en la clase!
044073=¡La clase {0} tiene propiedad {1} definido en el MetaData, pero el "getter" metodo no existe en la clase!
044074=¡La clase {0} tiene propiedad {1} definido en el MetaData, pero el "setter" metodo no existe en la clase!

044075=Populating Meta-Data for class {0}.
044076=Initialising Meta-Data for class {0}.

044077=La clase {0} ha sido definido con el object-id class {1} pero no hay ningun campo como "primary key". Por favor debes anotar con el tag "primary-key" los campos usar como parte de la llave primaria
044078=Class {0} has been specified with {1} primary key fields, but this class is using {2} identity and should be application identity.

044079=La clase {0} ha sido definido con el object-id class {1}. La clase no existe. Por favor, compruebe el especficación o CLASSPATH.
044080=La clase {0} tiene MetaData pero la clase no existe. Por favor compruebe la especificación de CLASSPATH.
044081=La clase {0} ha sido definido con un persistence-capable-superclass {1} pero no existe.
044082=La clase {0} ha sido definido con un persistence-capable-superclass {1} que no es un superclass de esa clase.
044083=La clase {0} ha sido definido con un persistence-capable-superclass {1} que no es Persistence-Capable (no hay Meta-Data).
044087=The persistence-capable-superclass for class {0} must be class {1}, NOT class {2}.
044088=The persistence-capable-superclass {1} for class {0} cant be found. Please check your CLASSPATH specifications.
044089=DataNucleus ha puesto un valor de persistence-capable-superclass "{1}" por la clase "{0}"; no tenia valor en el MetaData.
044090=La clase {0} ya tiene un campo con el nombre {1}.

044099=La clase {0} tiene una estrategia de heredar de SUPERCLASS, pero no hay una superclase!
044091=La clase "{0}" no tiene un persistence-capable-superclass, pero tiene una superclase "{1}" que ES PersistenceCapable. Corrigalo por favor.

044093=El tipo de identidad en la clase "{0}" no es lo mismo que el tipo de identidad en la superclase.
044094=La estrategia de Datastore-identity en la clase "{0}" ("{1}") no es la misma que la estrategia de Datastore-Identity en la superclase ("{2}").

044095=La clase "{0}" va a tener su definición internal de MetaData aumentado con información de annotaciones
044096=La clase "{0}" va a tener su definición internal de MetaData aumentado con información de ORM MetaData
044097=La clase {0} tiene MetaData con implements {1} pero la clase no existe! Por favor compruebe el CLASSPATH y MetaData.
044098=La clase {0} tiene una estrategia de heredar de "{1}" pero apoyamos "{2}" solamente.
044099=La clase {0} tiene una estrategia de heredar de "superclass-table", pero no superclase existe o no existe con propia tabla
044100=La clase {0} tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene un discriminador.
044101=La clase {0} tiene una estrategia de heredar de "superclass-table", usando la tabla {1}, pero esa clase no tiene una columna de discriminador
044102=La clase {0} tiene una estrategia de heredar usando la tabla de clase {1} con la columna de discriminador {2}. Esta clase no tiene un valor de discriminador
044103=La clase {0} usa la estrategia de discriminación de "value-map" pero no tiene valor. Vamos a usar el nombre de la clase!

044104=La clase "{0}" tiene una estrategia de "{1}" pero DataNucleus no la apoya. Usamos el "default"

044105=No hay un cargador de clases definido para cargar las clases con el MetaData por campo "{0}" de clase "{1}". Va a usar el cargador de clases del sistema.
044106=No puede popular el campo "{0}" de la clase "{1}" con un campo nulo.
044107=No puede popular el campo "{0}" de la clase "{1}" no ya ha sido populado.
044108=No puede cambiar el campo "{0}" de la clase "{1}" porque ya ha sido inicializado.
044109=Error en el MetaData por el campo "{0}" de la clase "{1}" : es definido como {2} con "persistence-modifier={3}" pero tiene "default-fetch-group=true" o "primary-key=true" definido! Deben ser falsos.
044111=No podemos persistir el campo "{0}" de la clase {1} porque es de un tipo de array que DataNucleus no apoya. Por favor, debe cambiarlo por una colección.
044112=El campo "{0}" ya existe en la clase "{1}", pero tiene otra definición.
044113=La clase "{0}" tiene campo "{1}" como de la clase "{2}" pero no hemos encontrado esta clase
044114=La clase "{0}" tiene campo "{1}" como de la clase "{2}" pero no es una superclase! Usted puede usar solamente los campos de las superclases que son PersistenceCapable.
044115=La clase "{0}" tiene campo "{2}" con "mapped-by" de "{2}". Este campo no existe en el otro lado de la relación ("{3}")!!
044116=La clase "{0}" tiene campo "{1}" con "implementation-classes" pero la clase de implementación "{2}" no existe!!
044117=Cannot populate the field "{0}" of the class "{1}" with a the value "{2}" for the property "{3}".

044118=Una columna tiene el jdbc-type de "{0}". Es invalido. El jdbc-type no existe en la lista de la clase java.sql.Types class, o DataNucleus no lo apoya.
044119=Una columna sin campo de la clase "{0}" ha sido especificado sin el nombre. Cualquier columna sin campo tiene que tener un nombre
044120=Una columna "{0}" sin campo de la clase "{1}" ha sido especificado sin el tipo de JDBC. Cualquier columna sin campo tiene que tener un tipo de JDBC

044121=El campo "{0}" tiene tipo "{1}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044122=El campo "{0}" es una collección de elementos de tipo "{1}" pero es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044123=El campo "{0}" es una mapa con llaves de tipo "{1}" pero la llave es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044124=El campo "{0}" es una mapa con valores de tipo "{1}" pero el valor es "embedded". DataNucleus no apoya usar este tipo como "embedded". El tipo del campo tiene que ser PersistenceCapable.
044125=Añadiendo el Meta-Data por el campo "{0}" de la clase "{1}" "embedded" en la clase "{2}" como no estaba en la definición de <embedded> Meta-Data.
044126=El campo "{0}" es una collección de elementos de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque los elementos van a estar almacenado alli.
044127=El campo "{0}" es una mapa de llaves de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque las llaves van a estar almacenado alli.
044128=El campo "{0}" es una mapa de valores de tipo "{1}" como "embedded". No hay ningun <join>. Usted necesita poner un <join>, porque los valores van a estar almacenado alli.
044129=El campo "{0}" tiene como "embedded" un objeto de tipo "{1}", pero es "interface" y lo has especificado con un CAMPO "{2}". Debe ser una PROPIEDAD.
044130=El campo "{0}" tiene <join table="...">. El atributo "table" no tiene sentido cuando <join> esta dentro de <field>. En este caso usted debe poner "table" en <field>.
044131=El campo "{0}" de la clase "{1}" ha sido definido con <collection> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044132=El campo "{0}" de la clase "{1}" ha sido definido con el "collection" MetaData pero no es un campo de Collection.
044133=¡El campo "{0}" de la clase "{1}" ha sido definido como Collection pero el tipo de elemento no ha sido definido!
044134=El campo "{0}" de la clase "{1}" ha sido definido como Collection con elementos de tipo {2}. ¡Este tipo de elemento no existe!
044135=El campo "{0}" de la clase "{1}" ha sido definido como Collection con elementos de tipo {2}. Este tipo ha sido resuelto a  {3}
044136=El campo "{0}" es una collección de (non-serializado) elementos de tipo "{1}" pero no tiene ningun <join>. Para almacenar una collección asi necesita una tabla de juntar, o marcarlo como "serialized".
044137=El campo "{0}" tiene mapped-by de <order> pero el campo ("{1}.{2}") no existe!
044138=El campo "{0}" tiene ordering con un campo ("{1}.{2}") que no existe!
044139=El campo "{0}" tiene ordering con una dirección invalida ("{1}"). Debe ser ASC o DESC
044140=El campo "{0}" de la clase "{1}" ha sido definido con <array> y element-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "implementation-classes" extension de DataNucleus.
044141=El campo "{0}" de la clase "{1}" ha sido definido con <array> MetaData pero no es un campo de array.
044142=El campo "{0}" es una matriz de (non-serializado) elementos de tipo "{1}" pero no tiene ningun <join>. Para almacenar una matriz asi necesita una tabla de juntar, o marcarlo como "serialized".
044143=El campo "{0}" de la clase "{1}" ha sido definido con <map> y key-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "key-implementation-classes" extension de DataNucleus.
044144=El campo "{0}" de la clase "{1}" ha sido definido con <map> y value-type contiene mas que un valor. DataNucleus apoya solo un valor. Si usted quiere especificar muchas implementaciones debe usar "value-implementation-classes" extension de DataNucleus.
044145=El campo "{0}" de la clase "{1}" ha sido definido con "map" MetaData pero no es un campo de Map.
044146=¡El campo "{0}" de la clase "{1}" ha sido definido como Map pero el tipo de key no ha sido definido!
044147=El campo "{0}" de la clase "{1}" ha sido definido como Map con keys del tipo {2}. ¡Este tipo de key no existe!
044148=El campo "{0}" de la clase "{1}" ha sido definido como Map con keys de tipo {2}. Este tipo de key ha sido resuelto a {3}.
044149=El campo "{0}" de la clase "{1}" ha sido definido como Map pero el tipo de value no ha sido definido!
044150=El campo "{0}" de la clase {1} ha sido definido como Map con values del tipo {2}. ¡Este tipo de value no existe!
044151=El campo "{0}" de la clase "{1}" ha sido definido como Map con values del tipo {2}. Este tipo de value ha sido resuelto a {3}.
044152=El campo "{0}" tiene key-type como "{1}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044153=El campo "{0}" tiene value-type como "{1}" que es tipo de referencia, y tiene "embedded". DataNucleus no apoya el uso de un tipo de referencia con "embedded".
044154=¡Query no tiene un nombre ! Por favor, cada Query necesita un nombre.
044155=¡Sequence no tiene un nombre ! Por favor, cada Sequence necesita un nombre.
044156=La estratagia no esta !
044157=La estratagia no esta !
044158=El factory-class {0} no esta !
044159=El factory-class {0} no hace javax.jdo.IdGenerator !
044160=La especificación del tag de <extension> no esta correcta. El vendor-name ({0}), key ({1}) y value ({2}) deben ser especificados.
044161=El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) but no hay clases de implementación de "{1}"

044200=La clase "{0}" tiene anotaciones de {1} y vamos a usarlas.
044201=La clase "{0}" tiene anotación "{1}" con propiedad "{2}" pero es invalido. Por favor compruebe la especificación para esta anotación.
044202=La clase "{0}" tiene anotaciones pero no hay ningún AnnotationReader registrado para este tipo de anotaciones. Por favor compruebe el CLASSPATH y las anotaciones para validez.
044203=La clase/el campo "{0}" tiene anotación "{1}" que no era posible procesar

044204=@Index especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora
044205=@Unique especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora
044206=@ForeignKey especificado por la clase "{0}" pero no hay campos/columnas asi que JPOX lo ignora

044207=La clase "{0}" tiene especificación de @FetchPlan y @FetchPlans. Usted debe poner solo una
044208=La clase "{0}" tiene especificación de @FetchGroup y @FetchGroups. Usted debe poner solo una
044209=La clase "{0}" tiene especificación de @Query y @Queries. Usted debe poner solo una
044210=La clase "{0}" tiene especificación de @Join y @Joins. Usted debe poner solo una

#
# Query Result
#
052600=El resultado del Query ya esta cerrado
052601=Ha encontrado un error leyendo el ResultSet : {0}
052602=No hay más elementos en el resultado del Query
052603=No puede cambiar el ResultSet del Query
052604=No apoyamos esta operación en el resultado de un Query
052605=Cerrar el resultado del Query da un error : {0}
052606=Leyendo los resultados del query "{0}" como la conneccion va a cerrar

#
# SQL
#
059000=No apoyamos borración por Query de SQL/DataNucleusSQL.
059001=Tiene un Query de SQL que esta vacia. Es invalido
059002=El estatement de SQL ("{0}") no empieza con SELECT. Es invalido
059004=No se puede usar Extent de Candidatos con un Query de SQL.
059005=No se puede usar collecciones de Candidato con un Query de SQL.
059006=No se puede poner el resultado con un Query de SQL.
059007=No se puede poner el serie con un Query de SQL.
059008=No se puede poner un filtro con un Query de SQL.
059009=No se puede usar variables con un Query de SQL.
059010=SQL apoya grouping pero explicitamente como GROUP BY en el texto de SQL.
059011=SQL apoya ordering pero explicitamente como ORDER BY en el texto de SQL.
059012=Query de SQL : "{0}"
059016=No se puede usar parametros con un Query de SQL.
059025=Error con la ejecucion de Query de SQL "{0}".
059026=No se puede usarlos imports con un Query de SQL.
059028=SQL query "{0}" necesita {1} parametros pero no hay ninguno
059030=SQL query "{0}" necesita un parametro con nombre "{1}" pero no hay ninguno en el Map
